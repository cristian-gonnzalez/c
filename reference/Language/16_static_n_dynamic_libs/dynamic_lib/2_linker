
Linking Against Shared Libraries:
--------------------------------

1. Compile the source code

            $ gcc ./src/main.c -o prog
            ./src/main.c:13:10: fatal error: cmath.h: No such file or directory
            13 | #include "cmath.h"
                |          ^~~~~~~~~
            compilation terminated.

    Again, the compiler cannot find the .h file we include. We tell the compiler
  where to find with the '-I' option.

            $ gcc ./src/main.c -o prog -I./include
            /usr/bin/ld: /tmp/ccfBJMv7.o: in function `main':
            main.c:(.text+0x13): undefined reference to `add'
            /usr/bin/ld: main.c:(.text+0x35): undefined reference to `mult'
            collect2: error: ld returned 1 exit status

    These errors are NOT coming from the compiler. They are coming from the linker.

    The compiler successfully compiled main.c, but the linker could not find the 
  implementations of the functions add() and mult().

NOTE: 
    Linker errors usually are 'undefined reference' type mesages.
    They indicate that symbol declarations exist, but implementations are missing at link time
    Implementations are expected to be found in .o, .a, or .so files

2. Link the shared libraries

    Lets try with -l option

                                                   ^~         ^~
            $ gcc ./src/main.c -o prog -I./include -lcmath.so -lcmult.so
            /usr/bin/ld: cannot find -lcmath.so
            /usr/bin/ld: cannot find -lcmult.so
            collect2: error: ld returned 1 exit status

    We can tell the compiler where to search the libraries with the -L option

                                                                    Library search path
                                                                        ^~   
            $ gcc ./src/main.c -o prog -I./include -lcmath.so -lcmult.so -L./
            /usr/bin/ld: cannot find -lcmath.so
            /usr/bin/ld: cannot find -lcmult.so
            collect2: error: ld returned 1 exit status

    NOTE:
      Pay close attention to what the -l (lowercase L) option does.

        -lcmath tells the linker to search for: lib<name>.<type>

            libcmath.so   (shared)
            libcmath.a    (static)

        When using -l, you do NOT include the 'lib' prefix or '.so' suffix.


    Lets try renaming the libs

            $ mv cmath.so libcmath.so
            $ mv cmult.so libcmult.so

            $ gcc ./src/main.c -o prog -I./include -lcmath -lcmult -L./


    The linker succeeded, but the runtime loader cannot find the shared libraries.
    
            $ ./prog 
            ./prog: error while loading shared libraries: libcmath.so: cannot open shared object file: No such file or directory


    The runtime loader must know where to find shared libraries. So we need to specify the LD_LIBRARY_PATH. 

            $ LD_LIBRARY_PATH="./" ./prog
            add(4, 7) = 11
            mult(4, 7) = 28

NOTE:
    - You can put your libraries in a know standard system locations (e.g., /lib, /usr/lib)
    - Often times, program launchers or scripts often set LD_LIBRARY_PATH automatically


--- Inspect unresolved symbols:

$ objdump -t prog 

prog:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000       F *UND*  0000000000000000              add
0000000000000000       F *UND*  0000000000000000              mult
                          ~~~
                          Undifined

                This tools is telling me that the function exitst but they dont know
                what to do with this. That's why we need to specify where to look for

  This output shows that the symbols add and mult exist but are undefined
in the executable. Their implementations are expected to be resolved
at runtime from shared libraries.